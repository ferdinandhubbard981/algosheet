independant set definition

tip for medium questions:
apply an algorithm you know in a clever way, don't write a new algorithm.
fibonacci heap

wk1:
big o:
slide 4 of big o slides with notation descriptions

week 2:
interval scheduling:
interval scheduling algorithms and complexity etc...
interval scheduling algorithms proofs

graph theory:
all definitions of graph properties with examples if necessary
{Graph, edge, verted, component, degree, walk, isomorphism, euler walk, connected, 
digraph, strongly connected, weakly connected, in-degree, out-degree, 
cycle, hamilton cycle, }


all graph notation:
component is x subset G
component is also a graph
strong component definition (not same as strongly connected)
G{a, b ,c} is a graph
{a, b, c} is a set of vertices

proof that all walks from u to v contain path from u to v
week 3:
digraph:
N+() and N-() notation
d+() and d-()
euler walk and weakly/ stronly connected properties and proof
strongly connected includes isolated vertex
5F and 5h proof
euler walk undirected graph d+ = d- except for start and end

5f proof

Dirac's theorem, definition, proof (3 lemmas)

handshaking lemma  definition and proof
k-regular graph definition
directed handshaking lemma definition and proof

trees:

definitions {forest, tree, degree of a TREE}
definitions and proofs:
{lemma 1, lemma 2, lemma 3}
Equivalence/ implication proofs for:
{
    A: T is connected and has no cycles: ie a tree
    B: T has n-1 edges and is connected
    C: T has n-1 edges and no cycles
    D: T has a unique path beween any pair of vertices
} 
A => B, C, D
B, C, D => A

claim on slide 12 of trees proof and definition

week 4:
adjacency matrix example
adjacency list example [s] -> a, b

complexity times:
{
    sort array of lists
    adjacency query
    neighbourhood query
    dfs
    bfs
    dijkstra
    each of dijkstra operations (slide 7)
}
adjacency list vs matrices (1 sentence describing in practice)

search:
dfs:
component finding basic brute force search explained/ pseudocode
depth first search explained/ pseudocode
dfs search correctness proof by induction
DFS tree always gives DFS tree proof
loop invariant
complexity analysis

bfs:
distance definition for undirected and directed (with base cases)
bfs search explained/ pseudocode

explanation: BFS works by starting at a vertex and then adding all adjacent vertices to a queue.
We then take the first vertex in the queue and look for a new set of adjacent vertices to add,
repeating the process until we have reached our destination.

BFS tree definition
Proof: the tree of edges from pred is always a BFS tree
loop invariant
complexity analysis

dijkstra:
weighted graph definition
weight function definition
length definition
distance definition
dijkstra algorithm proof by induction
relevant operations definitions (slide 7)
dijkstra algorithm explanation/ pseudocode
loop invariant
complexity analysis

week 5:
definitions: {
    matching: a collection of disjoint edges
    perfect matching: a matching where every vertex in contained in some mathing edge
    bipartite graph: a graph G is bipartite if V(G) can be split into two sets A and B, which contain no edges(between the elements of the set).
    augmenting path: given a matching M and a BIPARTITE graph G, an augmenting path for M is an augmenting path in G which alternates between matching and non-matching edges. Starting and ending with non-matched vertices.
    augmenting path formal definition:
    
}

proof: {
    G is bipartite if it has not odd length cycle
    G is bipartite only if it has not odd length cycle
} 
2nd slideshow:
simple greedy matching algorithm explanation
switch(M, P) explanation and pseudocode: {
    explanation: {
        let x be the odd (matching) edges in augmeting path A.
        let y be the even (non-matching) edges in augmenting path A.
        remove x from M
        add y to M
        return M // here M is bigger than before by 1 matching because len(y) = len(x) + 1
    }
}
MaxMatching explanation and pseudocode (digraph version)
loop invariant of MaxMatching
complexity of MaxMatching
explain how to contruct temporary digraph in order to find augmenting path for bipartite graph G with matching M.
proof of augmenting path using temp digraph
berg's lemma proof (if G has no augmenting paths, them matching is maximum)

slideshow 3:
definitions: {
    spanning tree
    minimum spanning tree
}

prim's algorithm explanation
prim's algorithm formal explanation
prim's algorithm pseudocode
prim's algorithm time/space complexity
prim's algorithm loop invariant
prim's algorithm correctness proof

